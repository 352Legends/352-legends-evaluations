<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>352 Legends Player Evaluations</title>
    <!-- Link to PWA manifest -->
    <link rel="manifest" href="manifest.json">
    <style>
        /*
         * Modern, mobile-first styling with a polished red, white and blue palette.
         * The layout uses generous padding, larger fonts and card-like containers
         * to make the interface feel contemporary and easy to use on small screens.
         */
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background-color: #f4f6fb;
            margin: 0;
            padding: 12px;
            color: #1a1a1a;
        }
        h1 {
            text-align: center;
            color: #002b5c;
            margin: 0 0 12px 0;
            font-size: 1.8rem;
        }
        /* Card container for the master controls and forms */
        .card {
            background: #ffffff;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 16px;
            margin-bottom: 12px;
        }
        .form-group {
            margin-bottom: 12px;
        }
        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            font-size: 0.95rem;
        }
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #cfd6e3;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 1rem;
            background-color: #f9fbff;
        }
        .form-group textarea { resize: vertical; }
        /* Grid for numeric ratings */
        .ratings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }
        /* Buttons */
        .btn {
            padding: 10px 18px;
            margin-top: 10px;
            border: none;
            border-radius: 6px;
            color: #ffffff;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 1rem;
            display: inline-block;
        }
        .btn-primary { background-color: #00479d; }
        .btn-primary:hover { background-color: #00336e; }
        .btn-secondary { background-color: #0066cc; }
        .btn-secondary:hover { background-color: #004f99; }
        .btn-danger { background-color: #c62828; }
        .btn-danger:hover { background-color: #a41e1e; }
        /* Table styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
            background: #ffffff;
            border-radius: 8px;
            overflow-x: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 0.85rem;
        }
        th {
            background-color: #002b5c;
            color: #ffffff;
            font-weight: 600;
            padding: 8px;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        tbody tr:nth-child(even) { background-color: #f1f5fa; }
        th, td {
            border: 1px solid #e1e7f0;
            padding: 8px;
            text-align: left;
        }
        /* Group header style */
        .group-header {
            background-color: #ffe5e5;
            color: #c62828;
            font-weight: 700;
            text-align: left;
        }
        /* Highlight master controls */
        #masterAgeGroup, #masterScout {
            background-color: #fff6f6;
            border-color: #c62828;
        }
        /* All-star star styling */
        .all-star-checkbox input[type="checkbox"] {
            display: none;
        }
        .all-star-checkbox span.star {
            font-size: 1.5rem;
            color: #d0d4db;
            margin-right: 4px;
            vertical-align: middle;
        }
        .all-star-checkbox input[type="checkbox"]:checked + span.star {
            color: #ffb400;
        }
        .all-star-label {
            font-weight: 600;
            font-size: 0.95rem;
            vertical-align: middle;
        }

        /* Star rating styles for skill evaluations */
        .star-rating {
            display: flex;
            gap: 4px;
        }
        .star-rating .star {
            font-size: 1.4rem;
            color: #d0d4db;
            cursor: pointer;
            transition: color 0.2s;
        }
        .star-rating .star.selected {
            color: #ffb400;
        }
        .star-rating .star:hover {
            color: #ff9800;
        }
    </style>
</head>
<body>
    <h1>352 Legends Player Evaluations</h1>
    <!-- Master controls -->
    <div style="max-width: 100%; margin: 0 auto 10px auto; background: #fff; padding: 10px; border-radius: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.05);">
        <div class="form-group">
            <label for="masterScout"><strong>Scout Name</strong></label>
            <input type="text" id="masterScout" placeholder="Enter scout name" />
        </div>
        <div class="form-group">
            <label for="masterAgeGroup"><strong>Default Age Group</strong></label>
            <select id="masterAgeGroup">
                <option value="">Select age group</option>
                <option value="5U">5U</option>
                <option value="7U">7U</option>
                <option value="9U">9U</option>
                <option value="11U">11U</option>
                <option value="13U">13U</option>
                <option value="Girls 6-8">Girls 6-8</option>
                <option value="Girls 9-11">Girls 9-11</option>
                <option value="Girls 12-14">Girls 12-14</option>
                <option value="Coed Highschool">Coed Highschool</option>
            </select>
        </div>
    </div>

    <form id="evaluationForm">
        <!-- All-Star selection placed above player name -->
        <div class="form-group">
            <label class="all-star-checkbox">
                <input type="checkbox" id="allStar">
                <span class="star">&#9733;</span>
                <span class="all-star-label">All-Star</span>
            </label>
        </div>
        <!-- Player basic information -->
        <div class="form-group">
            <label for="playerName">Player Name</label>
            <input type="text" id="playerName" placeholder="Enter player name" />
        </div>
        <div class="form-group">
            <label for="playerNumber">Player Number</label>
            <select id="playerNumber">
                <option value="" disabled selected>Select number</option>
                <!-- Player numbers added via script -->
            </select>
        </div>
        <div class="form-group" id="genderGroup">
            <label for="gender">Gender</label>
            <select id="gender">
                <option value="" disabled selected>Select gender</option>
                <option value="Male">Male</option>
                <option value="Female">Female</option>
                <option value="Non‑binary/Other">Non‑binary/Other</option>
            </select>
        </div>
        <div class="form-group" id="ageGroupContainer" style="display:none;">
            <label for="ageGroup">Age Group <span style="color:#c21807;">*</span></label>
            <select id="ageGroup" required>
                <option value="" disabled selected>Select age group</option>
                <option value="5U">5U</option>
                <option value="7U">7U</option>
                <option value="9U">9U</option>
                <option value="11U">11U</option>
                <option value="13U">13U</option>
                <option value="Girls 6-8">Girls 6-8</option>
                <option value="Girls 9-11">Girls 9-11</option>
                <option value="Girls 12-14">Girls 12-14</option>
                <option value="Coed Highschool">Coed Highschool</option>
            </select>
        </div>
        <!-- 40 Yard Dash timer -->
        <div class="form-group" id="dashGroup">
            <label for="dashTime">40 Yard Dash (sec)</label>
            <div style="display:flex; align-items:center; gap: 8px;">
                <input type="text" id="dashTime" placeholder="--" readonly style="flex:1;">
                <!-- Single toggle button for start/stop -->
                <button type="button" class="btn btn-secondary" id="toggleDash" onclick="toggleDashTimer()">Start</button>
            </div>
        </div>
        <!-- Player photo capture -->
        <div class="form-group">
            <label for="playerPhoto">Player Photo</label>
            <input type="file" id="playerPhoto" accept="image/*" capture="environment">
            <div style="display:flex; align-items:center; gap:8px; margin-top:5px;">
                <img id="photoPreview" style="display:none; max-width:80px; border-radius:4px;">
                <button type="button" class="btn btn-danger" id="deletePhotoBtn" style="display:none; padding:6px 10px; font-size:0.8rem;" onclick="deletePhoto()">Delete Photo</button>
            </div>
        </div>
        <div class="ratings">
            <!-- Running star rating -->
            <div class="form-group">
                <label for="runningVal">Running</label>
                <div class="star-rating" id="runningRating">
                    <span class="star" data-value="1">&#9733;</span>
                    <span class="star" data-value="2">&#9733;</span>
                    <span class="star" data-value="3">&#9733;</span>
                    <span class="star" data-value="4">&#9733;</span>
                    <span class="star" data-value="5">&#9733;</span>
                </div>
                <input type="hidden" id="runningVal" value="">
            </div>
            <!-- Flag pulling star rating -->
            <div class="form-group">
                <label for="flagPullingVal">Flag Pulling</label>
                <div class="star-rating" id="flagPullingRating">
                    <span class="star" data-value="1">&#9733;</span>
                    <span class="star" data-value="2">&#9733;</span>
                    <span class="star" data-value="3">&#9733;</span>
                    <span class="star" data-value="4">&#9733;</span>
                    <span class="star" data-value="5">&#9733;</span>
                </div>
                <input type="hidden" id="flagPullingVal" value="">
            </div>
            <!-- Catching star rating -->
            <div class="form-group">
                <label for="catchingVal">Catching</label>
                <div class="star-rating" id="catchingRating">
                    <span class="star" data-value="1">&#9733;</span>
                    <span class="star" data-value="2">&#9733;</span>
                    <span class="star" data-value="3">&#9733;</span>
                    <span class="star" data-value="4">&#9733;</span>
                    <span class="star" data-value="5">&#9733;</span>
                </div>
                <input type="hidden" id="catchingVal" value="">
            </div>
            <!-- Defense star rating -->
            <div class="form-group">
                <label for="defenseVal">Defense</label>
                <div class="star-rating" id="defenseRating">
                    <span class="star" data-value="1">&#9733;</span>
                    <span class="star" data-value="2">&#9733;</span>
                    <span class="star" data-value="3">&#9733;</span>
                    <span class="star" data-value="4">&#9733;</span>
                    <span class="star" data-value="5">&#9733;</span>
                </div>
                <input type="hidden" id="defenseVal" value="">
            </div>
            <!-- Throwing star rating -->
            <div class="form-group">
                <label for="throwingVal">Throwing</label>
                <div class="star-rating" id="throwingRating">
                    <span class="star" data-value="1">&#9733;</span>
                    <span class="star" data-value="2">&#9733;</span>
                    <span class="star" data-value="3">&#9733;</span>
                    <span class="star" data-value="4">&#9733;</span>
                    <span class="star" data-value="5">&#9733;</span>
                </div>
                <input type="hidden" id="throwingVal" value="">
            </div>
            <!-- Attitude star rating -->
            <div class="form-group">
                <label for="attitudeVal">Attitude</label>
                <div class="star-rating" id="attitudeRating">
                    <span class="star" data-value="1">&#9733;</span>
                    <span class="star" data-value="2">&#9733;</span>
                    <span class="star" data-value="3">&#9733;</span>
                    <span class="star" data-value="4">&#9733;</span>
                    <span class="star" data-value="5">&#9733;</span>
                </div>
                <input type="hidden" id="attitudeVal" value="">
            </div>
        </div>
        <!-- Key positions -->
        <div class="form-group">
            <label for="pos1">Key Position 1</label>
            <select id="pos1">
                <option value="" disabled selected>Select position</option>
                <option value="QB">QB</option>
                <option value="WR">WR</option>
                <option value="RB">RB</option>
            </select>
        </div>
        <div class="form-group">
            <label for="pos2">Key Position 2</label>
            <select id="pos2">
                <option value="" disabled selected>Select position</option>
                <option value="QB">QB</option>
                <option value="WR">WR</option>
                <option value="RB">RB</option>
            </select>
        </div>
        <div class="form-group">
            <label for="comments">Comments</label>
            <textarea id="comments" rows="2"></textarea>
        </div>
        <button type="button" class="btn btn-secondary" onclick="exportCSV()">Export CSV</button>
        <button type="button" class="btn btn-secondary" onclick="document.getElementById('csvInput').click()">Import CSV</button>
        <button type="button" class="btn btn-danger" onclick="undoLast()">Undo</button>
        <!-- Hidden file input for CSV import -->
        <input type="file" id="csvInput" accept=".csv" style="display:none" onchange="handleCSVImport(event)" />
    </form>

    <!-- Sort controls (hidden until there is data) -->
    <div id="sortControls" style="display:none; margin-top: 10px; max-width: 100%;">
        <label for="sortOption"><strong>Sort by:</strong></label>
        <select id="sortOption" onchange="applySort()">
            <option value="">Age Group Order</option>
            <option value="number" selected>Player Number (Asc)</option>
            <option value="rating">Rating (Desc)</option>
        </select>
    </div>

    <table id="evaluationTable" style="display:none;">
        <thead>
            <tr>
                <th>#</th><th>Player Name</th><th>Number</th><th>Gender</th><th>Age Group</th><th>Running</th><th>Flag Pulling</th><th>Catching</th><th>Defense</th><th>Throwing</th><th>Attitude</th><th>Dash Times (sec)</th><th>Comments</th><th>Pos 1</th><th>Pos 2</th><th>Photo</th><th>Rating</th><th>All-Star</th><th>Edit</th><th>Delete</th>
            </tr>
        </thead>
        <tbody id="tableBody"></tbody>
    </table>

    <script>
        const evaluations = [];
        let editingIndex = null;
        const history = [];
        let lastPlayerNumber = '';

        const ageOrder = ['5U','7U','9U','11U','13U','Girls 6-8','Girls 9-11','Girls 12-14','Coed Highschool'];

        // Current sort criterion: default to 'number' so rows start sorted by player number
        let sortBy = 'number';

        // Populate player numbers on load
        window.addEventListener('DOMContentLoaded', () => {
            const numSelect = document.getElementById('playerNumber');
            for (let i = 1; i <= 99; i++) {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = i;
                numSelect.appendChild(opt);
            }
            // Set default age group from master
            const masterAge = document.getElementById('masterAgeGroup');
            masterAge.addEventListener('change', () => {
                document.getElementById('ageGroup').value = masterAge.value;
                updateGenderVisibility();
            });
            document.getElementById('ageGroup').value = masterAge.value;

            // Attach change handler to show/hide gender field based on selected age group
            const ageSelect = document.getElementById('ageGroup');
            ageSelect.addEventListener('change', updateGenderVisibility);
            // Initial call to set gender visibility on load
            updateGenderVisibility();

            // Initialize star rating widgets
            ['running','flagPulling','catching','defense','throwing','attitude'].forEach(prefix => {
                initStarRating(prefix);
            });

            // Automatically enter edit mode when a selected player number already exists
            numSelect.addEventListener('change', () => {
                const selectedNum = numSelect.value;
                if (!selectedNum) {
                    editingIndex = null;
                    return;
                }
                const existingIndex = evaluations.findIndex(ev => ev.playerNumber === selectedNum);
                if (existingIndex >= 0) {
                    // Load existing evaluation into edit mode
                    editEvaluation(existingIndex);
                } else {
                    // New player: reset editing index and clear form fields
                    editingIndex = null;
                    // Reset dash time to 0 and stop any running timer
                    document.getElementById('dashTime').value = '0';
                    resetDashTimer();
                    // Clear photo preview and data
                    playerPhotoData = null;
                    const preview = document.getElementById('photoPreview');
                    const deleteBtn = document.getElementById('deletePhotoBtn');
                    if (preview) preview.style.display = 'none';
                    if (deleteBtn) deleteBtn.style.display = 'none';
                    // Reset file input
                    const photoInput = document.getElementById('playerPhoto');
                    if (photoInput) photoInput.value = '';
                    // Clear basic fields
                    document.getElementById('playerName').value = '';
                    document.getElementById('gender').value = '';
                    document.getElementById('pos1').value = '';
                    document.getElementById('pos2').value = '';
                    document.getElementById('comments').value = '';
                    document.getElementById('allStar').checked = false;
                    // Reset star ratings for all skill fields
                    ['running','flagPulling','catching','defense','throwing','attitude'].forEach(prefix => {
                        setStarRating(prefix, '');
                    });
                    // Set age group to the master default for new entry
                    const masterVal = document.getElementById('masterAgeGroup').value;
                    document.getElementById('ageGroup').value = masterVal;
                    // Update gender visibility based on age group
                    updateGenderVisibility();
                }
            });

            // Attach auto-save handlers to form inputs. Whenever a field changes and a
            // player number is selected, the current evaluation is saved automatically.
            const autoSaveFields = [
                'playerName','gender','pos1','pos2','comments','allStar'
            ];
            autoSaveFields.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', () => autoSaveCurrent());
                    // For text inputs and textarea, also save on input for responsive saving
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                        el.addEventListener('input', () => autoSaveCurrent());
                    }
                }
            });
            // Save automatically when dash timer stops (handled in toggleDashTimer)
            // Save automatically when photo is selected or deleted (handled in respective functions)

            // Register service worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('service-worker.js').catch((err) => console.error('SW registration failed', err));
            }
        });

        // Show or hide the gender field depending on the selected age group. For Coed Highschool,
        // gender is visible; for other age groups it is hidden and cleared.
        function updateGenderVisibility() {
            const age = document.getElementById('ageGroup').value;
            const genderGroup = document.getElementById('genderGroup');
            if (!genderGroup) return;
            if (age === 'Coed Highschool') {
                genderGroup.style.display = '';
            } else {
                genderGroup.style.display = 'none';
                document.getElementById('gender').value = '';
            }
        }

        function addEvaluation() {
            const name = document.getElementById('playerName').value.trim();
            const playerNumber = document.getElementById('playerNumber').value;
            const gender = document.getElementById('gender').value;
            const ageGroup = document.getElementById('ageGroup').value;
            const running = document.getElementById('runningVal').value;
            const flagPulling = document.getElementById('flagPullingVal').value;
            const catching = document.getElementById('catchingVal').value;
            const defense = document.getElementById('defenseVal').value;
            const throwVal = document.getElementById('throwingVal').value;
            const throwing = throwVal ? throwVal : 'N/A';
            const attitude = document.getElementById('attitudeVal').value;
            const pos1 = document.getElementById('pos1').value;
            const pos2 = document.getElementById('pos2').value;
            const comments = document.getElementById('comments').value.trim();
            const dashTime = document.getElementById('dashTime').value.trim();
            const allStar = document.getElementById('allStar').checked;
            const masterScout = document.getElementById('masterScout').value.trim();
            if (!ageGroup) {
                alert('Please select an age group.');
                return;
            }
            if (!masterScout) {
                alert('Please enter the scout\'s name in the master field.');
                return;
            }
            const photo = playerPhotoData;
            // Build dashTimes array. Store any entered dash time as an array; will hold multiple times across evaluations.
            const dashTimes = [];
            if (dashTime) {
                dashTimes.push(dashTime);
            }
            // Build new evaluation object with dashTimes instead of single dashTime value.
            const newEval = { name, playerNumber, gender, ageGroup, running, flagPulling, catching, defense, throwing, attitude, dashTimes, comments, pos1, pos2, allStar, photo, scoutName: masterScout };
            if (editingIndex !== null) {
                // Updating existing evaluation: merge with new values via combineEvaluations
                history.push({ action: 'update', index: editingIndex, previous: { ...evaluations[editingIndex] } });
                const merged = combineEvaluations(evaluations[editingIndex], newEval);
                evaluations[editingIndex] = merged;
                editingIndex = null;
            } else {
                const existingIndex = evaluations.findIndex(ev => ev.playerNumber === playerNumber && playerNumber !== '');
                if (existingIndex >= 0) {
                    const oldEval = evaluations[existingIndex];
                    const combined = combineEvaluations(oldEval, newEval);
                    history.push({ action: 'update', index: existingIndex, previous: { ...oldEval } });
                    evaluations[existingIndex] = combined;
                } else {
                    evaluations.push(newEval);
                    history.push({ action: 'add', index: evaluations.length - 1 });
                }
            }
            lastPlayerNumber = playerNumber;
            renderTable();
            clearForm();
        }

        function renderTable() {
            const table = document.getElementById('evaluationTable');
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            // Sort evaluations by age group and current sort criterion within group
            const sorted = evaluations.map((ev, idx) => ({ ev, origIndex: idx })).sort((a, b) => {
                // sort by age group order first
                const ai = ageOrder.indexOf(a.ev.ageGroup);
                const bi = ageOrder.indexOf(b.ev.ageGroup);
                const aiPos = ai >= 0 ? ai : ageOrder.length;
                const biPos = bi >= 0 ? bi : ageOrder.length;
                if (aiPos !== biPos) return aiPos - biPos;
                // within same age group, apply sort criterion
                if (sortBy === 'number') {
                    const aNum = parseInt(a.ev.playerNumber) || 0;
                    const bNum = parseInt(b.ev.playerNumber) || 0;
                    if (aNum !== bNum) return aNum - bNum;
                } else if (sortBy === 'rating') {
                    const ratingDiff = computeNumericAverage(b.ev) - computeNumericAverage(a.ev);
                    if (ratingDiff !== 0) return ratingDiff;
                }
                // fallback to insertion order
                return a.origIndex - b.origIndex;
            });
            let currentGroup = null;
            let displayIndex = 1;
            sorted.forEach(({ ev, origIndex }) => {
                if (ev.ageGroup !== currentGroup) {
                    currentGroup = ev.ageGroup || '';
                    const groupRow = document.createElement('tr');
                    const groupCell = document.createElement('td');
                    // Update colspan to reflect total number of columns (including All-Star)
                    groupCell.colSpan = 20;
                    groupCell.className = 'group-header';
                    groupCell.textContent = currentGroup ? `Age Group: ${currentGroup}` : 'Age Group: (unspecified)';
                    groupRow.appendChild(groupCell);
                    tbody.appendChild(groupRow);
                }
                const row = document.createElement('tr');
                const starRating = computeStarRating(ev);
                row.innerHTML = `
                    <td>${displayIndex}</td>
                    <td>${ev.name || ''}</td>
                    <td>${ev.playerNumber || ''}</td>
                    <td>${ev.gender || ''}</td>
                    <td>${ev.ageGroup || ''}</td>
                    <td>${ev.running || ''}</td>
                    <td>${ev.flagPulling || ''}</td>
                    <td>${ev.catching || ''}</td>
                    <td>${ev.defense || ''}</td>
                    <td>${ev.throwing || ''}</td>
                    <td>${ev.attitude || ''}</td>
                    <td>${getBestDashTimes(ev)}</td>
                    <td>${ev.comments || ''}</td>
                    <td>${ev.pos1 || ''}</td>
                    <td>${ev.pos2 || ''}</td>
                    <td>${ev.photo ? '<img src="' + ev.photo + '" style="max-width:50px;border-radius:3px;">' : ''}</td>
                    <td>${starRating}</td>
                    <td>${ev.allStar ? '★' : ''}</td>
                    <td><button type="button" class="btn btn-secondary" onclick="editEvaluation(${origIndex})">Edit</button></td>
                    <td><button type="button" class="btn btn-danger" onclick="deleteEvaluation(${origIndex})">Delete</button></td>
                `;
                tbody.appendChild(row);
                displayIndex++;
            });
            table.style.display = evaluations.length > 0 ? 'table' : 'none';
            // toggle sort controls visibility
            const sortControls = document.getElementById('sortControls');
            if (sortControls) {
                sortControls.style.display = evaluations.length > 0 ? 'block' : 'none';
            }
        }

        // Apply selected sort criterion and re-render the table
        function applySort() {
            const select = document.getElementById('sortOption');
            sortBy = select ? select.value : '';
            renderTable();
        }

        function editEvaluation(index) {
            const e = evaluations[index];
            document.getElementById('playerName').value = e.name;
            document.getElementById('playerNumber').value = e.playerNumber;
            document.getElementById('gender').value = e.gender;
            document.getElementById('ageGroup').value = e.ageGroup;
            // Update star ratings for skill fields
            setStarRating('running', e.running);
            setStarRating('flagPulling', e.flagPulling);
            setStarRating('catching', e.catching);
            setStarRating('defense', e.defense);
            if (e.throwing && e.throwing !== 'N/A') {
                setStarRating('throwing', e.throwing);
            } else {
                setStarRating('throwing', '');
            }
            setStarRating('attitude', e.attitude);
            document.getElementById('pos1').value = e.pos1 || '';
            document.getElementById('pos2').value = e.pos2 || '';
            document.getElementById('allStar').checked = !!e.allStar;
            document.getElementById('comments').value = e.comments;
            // Set dash time value when editing: display fastest recorded time
            let dashVal = '';
            if (e.dashTimes && e.dashTimes.length > 0) {
                const nums = e.dashTimes
                    .map(t => {
                        const n = parseFloat(t);
                        return isNaN(n) ? null : n;
                    })
                    .filter(n => n !== null);
                if (nums.length > 0) {
                    const min = Math.min(...nums);
                    dashVal = min.toFixed(2);
                }
            }
            document.getElementById('dashTime').value = dashVal;
            // Reset timer buttons when editing
            resetDashTimer();
            // Load photo preview when editing
            playerPhotoData = e.photo || null;
            const preview = document.getElementById('photoPreview');
            const deleteBtn = document.getElementById('deletePhotoBtn');
            if (playerPhotoData) {
                preview.src = playerPhotoData;
                preview.style.display = 'block';
                if (deleteBtn) deleteBtn.style.display = 'inline-block';
            } else {
                preview.style.display = 'none';
                if (deleteBtn) deleteBtn.style.display = 'none';
            }
            editingIndex = index;
            // Update gender field visibility when editing an existing player
            updateGenderVisibility();
        }

        function deleteEvaluation(index) {
            if (index >= 0 && index < evaluations.length) {
                const removed = evaluations[index];
                history.push({ action: 'delete', index: index, item: removed });
                evaluations.splice(index, 1);
                renderTable();
            }
        }

        function undoLast() {
            if (history.length === 0) {
                alert('Nothing to undo.');
                return;
            }
            const lastAction = history.pop();
            if (lastAction.action === 'add') {
                evaluations.splice(lastAction.index, 1);
            } else if (lastAction.action === 'update') {
                evaluations[lastAction.index] = lastAction.previous;
            } else if (lastAction.action === 'delete') {
                evaluations.splice(lastAction.index, 0, lastAction.item);
            }
            renderTable();
        }

        // Delete the currently loaded photo. If editing an existing evaluation, update the
        // evaluation's photo property and record the change for undo. Always clears
        // the preview and resets the file input.
        function deletePhoto() {
            // clear the photo data URL
            const prevPhoto = playerPhotoData;
            playerPhotoData = null;
            const preview = document.getElementById('photoPreview');
            const deleteBtn = document.getElementById('deletePhotoBtn');
            if (preview) preview.style.display = 'none';
            if (deleteBtn) deleteBtn.style.display = 'none';
            // clear the file input so a new photo can be selected
            const photoInput = document.getElementById('playerPhoto');
            if (photoInput) photoInput.value = '';
            // If editing an existing evaluation, update its photo field and push to history
            if (editingIndex !== null && evaluations[editingIndex]) {
                // Only record history if a photo was previously present
                if (evaluations[editingIndex].photo) {
                    history.push({ action: 'update', index: editingIndex, previous: { ...evaluations[editingIndex] } });
                    evaluations[editingIndex].photo = null;
                    renderTable();
                    // After deleting photo, save the updated evaluation state
                    autoSaveCurrent();
                }
            }
        }

        // Automatically save the current evaluation when a field changes. This
        // function constructs a new evaluation object from current form values
        // and merges it with any existing evaluation for the selected player.
        // It does not clear the form after saving.
        function autoSaveCurrent() {
            const playerNumber = document.getElementById('playerNumber').value;
            if (!playerNumber) return;
            const ageGroup = document.getElementById('ageGroup').value;
            // Require age group and scout name
            const masterScout = document.getElementById('masterScout').value.trim();
            if (!ageGroup || !masterScout) return;
            // Gather current field values
            const name = document.getElementById('playerName').value.trim();
            const gender = document.getElementById('gender').value;
            const running = document.getElementById('runningVal').value;
            const flagPulling = document.getElementById('flagPullingVal').value;
            const catching = document.getElementById('catchingVal').value;
            const defense = document.getElementById('defenseVal').value;
            const throwVal = document.getElementById('throwingVal').value;
            const throwing = throwVal ? throwVal : 'N/A';
            const attitude = document.getElementById('attitudeVal').value;
            const pos1 = document.getElementById('pos1').value;
            const pos2 = document.getElementById('pos2').value;
            const comments = document.getElementById('comments').value.trim();
            const allStar = document.getElementById('allStar').checked;
            // Use the current dash time input; if empty, treat as empty string (don't add to dashTimes)
            const dashTimeVal = document.getElementById('dashTime').value.trim();
            const dashTimes = [];
            if (dashTimeVal) {
                dashTimes.push(dashTimeVal);
            }
            const photo = playerPhotoData;
            const newEval = { name, playerNumber, gender, ageGroup, running, flagPulling, catching, defense, throwing, attitude, dashTimes, comments, pos1, pos2, allStar, photo, scoutName: masterScout };
            const existingIndex = evaluations.findIndex(ev => ev.playerNumber === playerNumber);
            if (existingIndex >= 0) {
                // merge with existing
                const oldEval = evaluations[existingIndex];
                const combined = combineEvaluations(oldEval, newEval);
                // record history for undo
                history.push({ action: 'update', index: existingIndex, previous: { ...oldEval } });
                evaluations[existingIndex] = combined;
                editingIndex = existingIndex;
            } else {
                // create new evaluation
                evaluations.push(newEval);
                history.push({ action: 'add', index: evaluations.length - 1 });
                editingIndex = evaluations.length - 1;
            }
            lastPlayerNumber = playerNumber;
            renderTable();
        }

        // Timer variables and functions for 40-yard dash
        let dashTimerInterval = null;
        let dashStartTime = null;

        // Photo data URL for captured player photo
        let playerPhotoData = null;

        // Toggle the 40-yard dash timer. When starting, it begins updating the display and changes the
        // button label to "Stop"; when stopping, it freezes the time and resets the label to "Start".
        function toggleDashTimer() {
            const btn = document.getElementById('toggleDash');
            if (dashTimerInterval === null) {
                dashStartTime = Date.now();
                dashTimerInterval = setInterval(() => {
                    const elapsed = (Date.now() - dashStartTime) / 1000;
                    document.getElementById('dashTime').value = elapsed.toFixed(2);
                }, 50);
                btn.textContent = 'Stop';
            } else {
                clearInterval(dashTimerInterval);
                dashTimerInterval = null;
                btn.textContent = 'Start';
                // When the timer stops, auto-save the recorded dash time for the player
                autoSaveCurrent();
            }
        }

        // Reset the dash timer and button state without clearing the recorded time.
        function resetDashTimer() {
            if (dashTimerInterval !== null) {
                clearInterval(dashTimerInterval);
                dashTimerInterval = null;
            }
            const btn = document.getElementById('toggleDash');
            if (btn) btn.textContent = 'Start';
        }

        // Handle player photo input change
        document.getElementById('playerPhoto').addEventListener('change', function (event) {
            const file = this.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function () {
                    playerPhotoData = reader.result;
                    const preview = document.getElementById('photoPreview');
                    preview.src = playerPhotoData;
                    preview.style.display = 'block';
                    const deleteBtn = document.getElementById('deletePhotoBtn');
                    if (deleteBtn) deleteBtn.style.display = 'inline-block';
                    // Auto-save the new photo for the selected player
                    autoSaveCurrent();
                };
                reader.readAsDataURL(file);
            }
        });

        function combineEvaluations(oldEval, newEval) {
            // Merge two evaluation objects. Fields in newEval always take precedence,
            // even if they are empty strings. This allows scouts to clear a
            // previously entered value (e.g. star ratings) by deselecting.
            const combined = { ...oldEval };

            // Helper to update a field. If allowBlank is true, always assign the
            // new value (including empty strings). Otherwise, only update when
            // the new value is a non-empty string.
            function updateField(field, allowBlank = false) {
                if (Object.prototype.hasOwnProperty.call(newEval, field)) {
                    const newVal = newEval[field];
                    if (allowBlank) {
                        combined[field] = newVal;
                    } else if (newVal && newVal !== '') {
                        combined[field] = newVal;
                    }
                }
            }

            // Basic fields
            updateField('name');
            updateField('gender', true);
            updateField('ageGroup', true);

            // Ratings: running, flag pulling, catching, defense, throwing, attitude
            ['running','flagPulling','catching','defense','throwing','attitude'].forEach(f => {
                updateField(f, true);
            });

            // Merge dash times. Convert legacy dashTime field to array if needed.
            const oldTimes = [];
            if (oldEval.dashTimes && Array.isArray(oldEval.dashTimes)) {
                oldEval.dashTimes.forEach(t => {
                    if (t) oldTimes.push(t);
                });
            } else if (oldEval.dashTime && oldEval.dashTime !== '') {
                oldTimes.push(oldEval.dashTime);
            }
            const newTimes = [];
            if (newEval.dashTimes && Array.isArray(newEval.dashTimes)) {
                newEval.dashTimes.forEach(t => {
                    if (t) newTimes.push(t);
                });
            } else if (newEval.dashTime && newEval.dashTime !== '') {
                newTimes.push(newEval.dashTime);
            }
            combined.dashTimes = [...oldTimes, ...newTimes];
            // Maintain dashTime field for backward compatibility (latest entry)
            combined.dashTime = combined.dashTimes.length > 0 ? combined.dashTimes[combined.dashTimes.length - 1] : '';

            // Photo and positions
            updateField('photo', true);
            updateField('pos1', true);
            updateField('pos2', true);
            updateField('scoutName', true);

            // Preserve all-star flag if either evaluation marks it
            combined.allStar = oldEval.allStar || newEval.allStar;

            // Replace comments with the latest provided comments
            if (Object.prototype.hasOwnProperty.call(newEval, 'comments')) {
                combined.comments = newEval.comments;
            }
            return combined;
        }

        function clearForm() {
            document.getElementById('evaluationForm').reset();
            // ensure all-star checkbox is cleared
            document.getElementById('allStar').checked = false;
            if (lastPlayerNumber) {
                document.getElementById('playerNumber').value = lastPlayerNumber;
            }
            const masterAge = document.getElementById('masterAgeGroup').value;
            document.getElementById('ageGroup').value = masterAge;
            // update gender visibility after resetting age group
            updateGenderVisibility();
            // reset dash time and timer button
            document.getElementById('dashTime').value = '';
            resetDashTimer();
            // reset photo input, preview and delete button
            playerPhotoData = null;
            const photoInput = document.getElementById('playerPhoto');
            if (photoInput) photoInput.value = '';
            const preview = document.getElementById('photoPreview');
            if (preview) preview.style.display = 'none';
            const deleteBtn = document.getElementById('deletePhotoBtn');
            if (deleteBtn) deleteBtn.style.display = 'none';

            // reset star ratings (clear hidden values and deselect stars)
            ['running','flagPulling','catching','defense','throwing','attitude'].forEach(prefix => {
                const hidden = document.getElementById(prefix + 'Val');
                const container = document.getElementById(prefix + 'Rating');
                if (hidden) hidden.value = '';
                if (container) {
                    const stars = container.querySelectorAll('.star');
                    stars.forEach(s => s.classList.remove('selected'));
                }
            });
        }

        function computeNumericAverage(ev) {
            const values = [];
            ['running','flagPulling','catching','defense','attitude'].forEach(f => {
                const v = ev[f];
                if (v && v !== '') {
                    const num = parseFloat(v);
                    if (!isNaN(num)) values.push(num);
                }
            });
            if (ev.throwing && ev.throwing !== '' && ev.throwing !== 'N/A') {
                const num = parseFloat(ev.throwing);
                if (!isNaN(num)) values.push(num);
            }
            if (values.length === 0) return 0;
            const sum = values.reduce((a,b) => a + b, 0);
            return sum / values.length;
        }

        // Initialize star rating groups. For each prefix (e.g. 'running'), attach
        // click handlers to the stars that set the selected value and update
        // appearance. When a star is clicked, it also triggers auto-save.
        function initStarRating(prefix) {
            const container = document.getElementById(prefix + 'Rating');
            const hidden = document.getElementById(prefix + 'Val');
            if (!container || !hidden) return;
            const stars = container.querySelectorAll('.star');
            stars.forEach(star => {
                star.addEventListener('click', () => {
                    const val = parseInt(star.getAttribute('data-value'));
                    const currentVal = parseInt(hidden.value);
                    // If the clicked star is already selected (same as current value), clear the rating
                    if (!isNaN(currentVal) && currentVal === val) {
                        hidden.value = '';
                        stars.forEach(s => s.classList.remove('selected'));
                    } else {
                        hidden.value = val;
                        stars.forEach(s => {
                            const sVal = parseInt(s.getAttribute('data-value'));
                            if (sVal <= val) {
                                s.classList.add('selected');
                            } else {
                                s.classList.remove('selected');
                            }
                        });
                    }
                    autoSaveCurrent();
                });
            });
        }

        // Set star rating value programmatically (used when editing). Clears
        // previous selection and marks stars up to the specified value.
        function setStarRating(prefix, value) {
            const container = document.getElementById(prefix + 'Rating');
            const hidden = document.getElementById(prefix + 'Val');
            if (!container || !hidden) return;
            const val = parseInt(value);
            hidden.value = (!isNaN(val) && val > 0) ? val : '';
            const stars = container.querySelectorAll('.star');
            stars.forEach(s => {
                const sVal = parseInt(s.getAttribute('data-value'));
                if (!isNaN(val) && sVal <= val) {
                    s.classList.add('selected');
                } else {
                    s.classList.remove('selected');
                }
            });
        }

        function computeStarRating(ev) {
            const avg = computeNumericAverage(ev);
            const stars = Math.round(avg);
            if (!stars) return '';
            return '★'.repeat(stars) + '☆'.repeat(5 - stars);
        }

        // Compute up to three best (lowest) dash times for display/export. Accepts
        // both string and numeric entries in ev.dashTimes and returns a formatted
        // semicolon-separated string. Each time is shown with two decimal places.
        function getBestDashTimes(ev) {
            if (!ev || !ev.dashTimes || ev.dashTimes.length === 0) return '';
            // Convert to numeric and filter out invalid entries
            const nums = ev.dashTimes
                .map(t => {
                    const n = parseFloat(t);
                    return isNaN(n) ? null : n;
                })
                .filter(n => n !== null);
            if (nums.length === 0) return '';
            // Sort ascending (best times first)
            nums.sort((a, b) => a - b);
            const best = nums.slice(0, 3);
            return best.map(n => n.toFixed(2)).join('; ');
        }

        function exportCSV() {
            if (evaluations.length === 0) {
                alert('No evaluations to export.');
                return;
            }
            const header = ['No.','Player Name','Number','Gender','Age Group','Running','Flag Pulling','Catching','Defense','Throwing','Attitude','Dash Times','Comments','Pos1','Pos2','Photo','Rating','All-Star','Scout Name'];
            const sorted = evaluations.map((ev, idx) => ({ ev, idx })).sort((a, b) => {
                const ai = ageOrder.indexOf(a.ev.ageGroup);
                const bi = ageOrder.indexOf(b.ev.ageGroup);
                const aiPos = ai >= 0 ? ai : ageOrder.length;
                const biPos = bi >= 0 ? bi : ageOrder.length;
                return aiPos - biPos || a.idx - b.idx;
            });
            const rows = sorted.map((item, idx) => [
                idx + 1,
                item.ev.name,
                item.ev.playerNumber,
                item.ev.gender,
                item.ev.ageGroup,
                item.ev.running,
                item.ev.flagPulling,
                item.ev.catching,
                item.ev.defense,
                item.ev.throwing,
                item.ev.attitude,
                getBestDashTimes(item.ev),
                item.ev.comments,
                item.ev.pos1,
                item.ev.pos2,
                item.ev.photo || '',
                computeStarRating(item.ev),
                item.ev.allStar ? 'Yes' : 'No',
                item.ev.scoutName
            ]);
            const csvContent = [header.join(','), ...rows.map(r => r.map(val => `"${val}"`).join(','))].join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'player_evaluations.csv');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Handle file selection for CSV import. Reads the selected file and passes
        // its contents to the CSV parser. Resets the file input afterwards to
        // allow repeated imports.
        function handleCSVImport(event) {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                importFromCSV(text);
            };
            reader.readAsText(file);
            // reset the input to allow selecting the same file again if needed
            event.target.value = '';
        }

        // Parse CSV text and add evaluations to the app. If a row's player number
        // already exists, the evaluation is combined with the existing one. CSV
        // fields are expected in the same order as the exported file.
        function importFromCSV(csvText) {
            const lines = csvText.trim().split(/\r?\n/);
            if (lines.length <= 1) {
                alert('The CSV file appears to be empty or malformed.');
                return;
            }
            // Skip header row
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const values = parseCSVLine(line);
                // remove surrounding quotes
                const row = values.map(v => v.replace(/^"(.*)"$/, '$1'));
                // Ensure there are enough columns (including dash time, photo, and scout name)
                if (row.length < 19) continue;
                // Parse dash times string (may contain up to 3 semicolon-separated times)
                const dashString = row[11] || '';
                let dashTimes = [];
                if (dashString) {
                    dashTimes = dashString.split(/;|,/).map(v => v.trim()).filter(v => v);
                }
                const evalObj = {
                    name: row[1] || '',
                    playerNumber: row[2] || '',
                    gender: row[3] || '',
                    ageGroup: row[4] || '',
                    running: row[5] || '',
                    flagPulling: row[6] || '',
                    catching: row[7] || '',
                    defense: row[8] || '',
                    throwing: row[9] || '',
                    attitude: row[10] || '',
                    dashTimes: dashTimes,
                    comments: row[12] || '',
                    pos1: row[13] || '',
                    pos2: row[14] || '',
                    photo: row[15] || '',
                    // rating column (16) is ignored; we recompute it dynamically
                    allStar: (row[17] && (row[17].toLowerCase() === 'yes' || row[17].includes('★'))) ? true : false,
                    scoutName: row[18] || ''
                };
                if (evalObj.playerNumber) {
                    const existingIndex = evaluations.findIndex(ev => ev.playerNumber === evalObj.playerNumber);
                    if (existingIndex >= 0) {
                        // combine with existing evaluation
                        const oldEval = evaluations[existingIndex];
                        const combined = combineEvaluations(oldEval, evalObj);
                        history.push({ action: 'update', index: existingIndex, previous: { ...oldEval } });
                        evaluations[existingIndex] = combined;
                    } else {
                        evaluations.push(evalObj);
                        history.push({ action: 'add', index: evaluations.length - 1 });
                    }
                }
            }
            renderTable();
        }

        // Split a CSV line into values. Handles quoted fields containing commas.
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        // Escaped quote within quoted value
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            return result;
        }
    </script>
</body>
</html>